<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">C-lisp and Flexible Macro Programming with S-expressions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2024-10-23">23 Oct 2024</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Vedanth</forename><surname>Padmaraman</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Sasank</forename><surname>Chilamkurthy</surname></persName>
						</author>
						<title level="a" type="main">C-lisp and Flexible Macro Programming with S-expressions</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2024-10-23">23 Oct 2024</date>
						</imprint>
					</monogr>
					<idno type="MD5">BAF2174BD0B4E608AEBCE57CCE917925</idno>
					<idno type="arXiv">arXiv:2410.16690v2[cs.PL]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2025-08-03T20:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Llama.lisp is a compiler framework intended to target offload processor backends such as GPUs, using intermediate representation languages (IRs) that are device-agnostic. The Llama.lisp IRs are formulated as S-expressions. This makes them easy to generate using higher level programming languages, which is one of the primary goals for Llama.lisp. The highest IR layer currently implemented in Llama.lisp is C-Lisp. In this paper, we describe the macro system developed for the Llama.lisp compiler framework. We show how we implemented FFI bindings as an example of this system.</p><p>Compilers are workhorses of performance behind all AI algorithms. Making algorithms work effectively on GPUs is especially hard -called kernel programming. The compiler ecosystem around GPUs is especially fragmented. They are supposed to allow for performance portability between different hardware architecture. Unfortunately, this is usually not the case.</p><p>We are designing a compiler framework called llama.lisp <ref type="bibr" target="#b1">[1]</ref> to solve this problem. As suggested by the name, the framework is highly inspired by Lisp and its syntax, S-expressions. A multi layered approach is adopted to tame the complexity of writing such a compiler framework. We implement C-lisp as one such layer. We show how lisp syntax has allowed for unique meta programming capabilities while being simple both to understand and implement.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">C-Lisp: Structured LLVM IR</head><p>C-Lisp serves as a structured programming <ref type="bibr" target="#b2">[2]</ref> interface to the LLVM <ref type="bibr" target="#b3">[3]</ref> instruction set, with semantics modelled after the C language <ref type="bibr" target="#b4">[4]</ref>. The S-expression syntax forms the base of the C-Lisp syntax. An Sexpression can be either a token or a list, the elements of which are also S-expressions. The first element of a list usually specifies an action (in which case it is a token), and the remainder of the elements specify the arguments to that action. By a slight extension of logic, S-expressions can also be viewed as trees: a list represents an internal node, the first element of the list the node type, and the remainder of the elements the node's children. For example, consider the following variable declaration in C: int var;</p><p>The root node of the abstract syntax tree (AST) for this statement is a declaration node; the children of the root node are the type int and the variable reference var. One could represent this AST using S-expressions like so:</p><p>(declare var int)</p><p>And it so happens that this is the exact syntax for variable declarations in C-Lisp.</p><p>Most expression opcodes in C-Lisp (i.e. directives that specify some computation) exhibit a close correspondence to instruction opcodes in the LLVM IR, in that they perform the same operations and take the same kinds of arguments. For example, the LLVM IR implements the fadd opcode for integer addition, with the syntax &lt;result&gt; = fadd [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; C-Lisp exposes a single form of this instruction, consisting of the compulsory operands, through its fadd expression opcode:</p><formula xml:id="formula_0">(fadd &lt;op1&gt; &lt;op2&gt;)</formula><p>Owing to the adoption of C semantics, it can be noted that the result is not specified in the fadd expression; the set opcode fulfills that purpose, and can be used with the fadd expression as an operand. Additionally, the type is inferred, not explicitly stated.</p><p>As an illustration of C-Lisp, consider the following C function to add the product of two numbers to the contents of a pointer. The function returns nothing, takes one pointer to a 64-bit integer and two 32-bit integers as arguments (the bit widths are platform-specific, but we shall assume these). On the face of it, there is a world of difference between the two versions. However, on closer observation, the C-Lisp version closely resembles the AST of the C version. Consider the assignment of mul_res in C: it is an assignment expression with mul_res as its first operand and a * b as its second. Further recursing into the second operand, it is a multiplication expression with a and b as operands. The C-Lisp version reflects this structure accurately, with set denoting an assignment and mul denoting a multiplication.</p><p>As a result, both implementations have similar semantics, and the executables produced from both perform equally well. However, the adoption of S-expressions makes it much more conducive to generate and programmatically interact with the C-Lisp version.</p><p>One main point of difference between semantics of two versions is the use of implicit casting. The C version adds mul_res, a 32-bit integer, to the contents of res, a 64-bit integer. This works because a compliant C compiler will insert an implicit cast from a 32-to a 64-bit integer, and thus behave as if the source program had stated *res = *res + (long int) mul_res;</p><p>C-Lisp, on the other hand, employs no implicit action whatsoever. The programmer is forced to explicitly cast mul_res to a 64-bit integer. This helps keep the C-Lisp language's implementation concise and simple. Additionally, the absence of implicit actions simplifies the analysis of these programs.</p><p>To ease the process of C-Lisp code generation, the JavaScript Object Notation (JSON) is used as an exchange format for C-Lisp. JSON has support for lists as well as the basic token types (integers, floating-point numbers and so on), which makes it an ideal choice for serializing S-expressions. Additionally, JSON enjoys support in most mature programming languages. The transformer from S-expression to JSON is written in Guile Scheme, and as such uses most of Scheme's conventions for capturing constructs such as unquote.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Macro Preprocessor</head><p>C-Lisp is intended to be minimal; most computation can be expressed in C-Lisp with reasonably simple code, and there is seldom more than one way to do so. This necessitates a strong macro system: one that enables extensions of C-Lisp, reducing the need for feature additions to the language. Prelisp aims to fulfill this need, borrowing from the multistage programming <ref type="bibr">[5]</ref> paradigm.</p><p>Prelisp uses Python as the macro language, although any modern general-purpose language could have been used. On the face of it, using a third-party language for the preprocessor can make for rather complicated macro definitions; however, owing to the adoption of the S-expression syntactical form, the process of C-Lisp code generation is greatly simplified. Thus, Python's own list data structure make it feasible to programmatically emit C-Lisp code. Additionally, Python makes for a good choice because it involves a minimal learning curve, and it leaves a powerful standard library and programming environment at the macro programmer's disposal.</p><p>The Prelisp preprocessor takes the input program as a JSON object. Portions of this object are recognized as macro expressions, evaluated using macro definitions from a supplied Python module (the "macro module" henceforth), and replaced to produce the result. A macro is expected to be defined in the global scope of the macro module, and is either referenced directly, like a variable, or called, like a function. In both cases, the macro evaluates to a Python object which is substituted in place of the macro expression and eventually serialized back into JSON along with the rest of the program. Macro expressions in the source program are denoted using either the unquote or the unquote-splicing constructs <ref type="bibr" target="#b6">[6]</ref>, borrowed from the Lisp family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Variable substitution</head><p>unquote can be used to substitute a single expression. The following expression ; In the source program (eq (call getchar) ,EOF)</p><p>is equivalent to the S-expression (eq (call getchar) (unquote EOF))</p><p>and thus is represented in JSON as</p><p>["eq", ["call", "getchar"], ["unquote", "EOF"]]</p><p>Given this macro expression, Prelisp recognizes EOF as the unquoted expression and looks for an object named EOF in the global scope of the macro module. With the following definition in the macro module # In the macro module EOF = ["trunc", -1, "int8"] the macro expression evaluates to</p><p>["eq", ["call", "getchar"], ["trunc", -1, "int8"]] and when converted back to S-expression form yields (eq (call getchar) (trunc -1 int8))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Parametric macros</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consider a function call-like macro expression:</head><p>; In the source program ,(incr var 45)</p><p>with the equivalent JSON form:</p><p>["unquote", ["incr", "var", 45]] and a corresponding definition in the macro module: # In the macro module def incr (name, amt) """(incr name, amt) -&gt; (set name (add name amt))""" return ["set", name, ["add", name, amt]]</p><p>Since the expression after unquote is a list, Prelisp infers incr to be the name of a callable in the macro module. The macro is evaluated by calling incr with arguments "var" and 45, and the resulting macro substitution's JSON form looks like this:</p><p>["set", "var", ["add", "var", 45]]</p><p>When converted back to the S-expression form:</p><p>(set var (add var 45))</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Splicing macros</head><p>unquote-splicing can be used to substitute multiple expressions in place of a single macro expression. An expression of the form ; In the source program ,@(declare_multiple (ch i) int)</p><p>is represented in JSON as</p><p>["unquote-splicing", ["declare_multiple", ["ch", "i"], "int"]]</p><p>Given the following macro definition, The macro expression is replaced with ["declare", "ch", "int"] ["declare", "i", "int"] Thus, in S-expression, this looks like</p><formula xml:id="formula_1">#</formula><formula xml:id="formula_2">(declare ch int) (declare i int)</formula><p>Note that if unquote (i.e. , instead of ,@) was used, both of the declare statements would be nested under a list, like so:</p><formula xml:id="formula_3">((declare ch int) (declare i int))</formula><p>Note that the return values of incr and declare_multiple are entirely composed of native Python data structures, and the literal expressions used to construct the return values closely resemble the actual Sexpressions that are emitted. This highlights the ease of C-Lisp code generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Example: Building an FFI System using Prelisp</head><p>C-Lisp is compatible with C at the ABI level. This means that libraries that can be used with C code can also be used with C-Lisp in a similar fashion. In C, using an external library typically involves placing forward definitions for the library's contents in the source program, and linking to the library's object file; the same holds for C-Lisp too.</p><p>Libraries are typically distributed along with header files containing forward declarations for their contents. C's #include preprocessor directive is typically the mechanism by which the forward declarations from these header files are brought into the source of a program that uses the library. Since C-Lisp uses C's data types, it is feasible to generate forward declarations in C-Lisp from forward declarations in C; consequently, a library's C header files can be used to generate C-Lisp bindings to the library.</p><p>Prelisp makes it possible to implement a solution for binding generation entirely in Python and expose it as a macro for use in a C-Lisp program. Such a solution is under active development, and is already in use by a test program that launches accelerated vector addition on an NVIDIA GPU using the CUDA driver API.</p><p>Parsing C is a relatively complex task, partly due to C's complicated syntax, and partly due to the presence of constructs in the C language that are outside the scope of C-Lisptypedef, enum, and so on. For these reasons, the actual parsing of C code is offloaded to the Clang frontend. Clang is used to produce two artifacts from a C header: the LLVM IR module and the AST in Clang's own JSON schema. The LLVM IR is then parsed using Numba's <ref type="bibr" target="#b7">[7]</ref> LLVMLite binding layer to yield function declarations and struct type definitions (collectively referred to as "signatures" henceforth), while type aliases (typedefs) are scraped from the JSON AST.</p><p>The binding generation process works on this premise. A Python module orchestrates the processes of running the Clang executable, saving its outputs, and processing the LLVM IR and the AST to yield declarations in C-Lisp. The process is as follows:</p><p>• Take input for desired headers, functions, structs and typedefs </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusion</head><p>The implementation of the Prelisp preprocessor system is a rather straightforward extension of the ideas it builds on, such as S-expression IRs and substitution using unquote. However, the combination of these ideas results in a powerful framework that made it possible to achieve on-the-fly bindings generation and inclusion with a few lines of Python code and minimal external dependencies.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>void muladd (long int * res, int a, int b) { int mul_res = a * b; *res = *res + mul_res; } An equivalent C-Lisp implementation would be: (define ((muladd void) (res (ptr int64)) (a int) (b int)) (declare mul_res int) (set mul_res (mul a b)) (store res (add (load res) (sext mul_res int64))))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>• Generate a C program that includes the desired header files uses each of the desired functions and structs • Compile the generated C program, saving its JSON AST and LLVM IR • Parse the IR to extract function and struct type signatures • Parse the JSON AST to extract typedef type aliases and function parameter namesThis same module, when used as a Prelisp macro module, serves as a convenient means of using definitions from external libraries. At present, its usage on the CUDA driver API is a single macro call:</figDesc><table><row><cell>,@(include</cell></row><row><cell>(/usr/local/cuda/include/cuda.h) ; Headers</cell></row><row><cell>(cuInit</cell></row><row><cell>cuDeviceGetCount</cell></row><row><cell>cuDeviceGet</cell></row><row><cell>cuCtxCreate_v2</cell></row><row><cell>cuModuleLoadDataEx</cell></row><row><cell>cuModuleGetFunction</cell></row><row><cell>cuMemAlloc_v2</cell></row><row><cell>cuMemcpyHtoD_v2</cell></row><row><cell>cuLaunchKernel</cell></row><row><cell>cuCtxSynchronize</cell></row><row><cell>cuMemcpyDtoH_v2</cell></row><row><cell>cuMemFree_v2</cell></row><row><cell>cuModuleUnload</cell></row><row><cell>cuCtxDestroy_v2) ; Functions</cell></row><row><cell>() ; Structs</cell></row><row><cell>(CUcontext CUmodule CUfunction CUstream CUdevice)) ; Typedefs</cell></row><row><cell>And this allows access to the CUDA driver API through rather familiar names:</cell></row><row><cell>(declare module ,CUmodule)</cell></row><row><cell>(declare kernel_func ,CUfunction)</cell></row><row><cell>; ...</cell></row><row><cell>(call cuModuleGetFunction (ptr-to kernel_func) module "kernel")</cell></row><row><cell>For reference, the equivalent C version would look like this:</cell></row><row><cell>#include &lt;cuda.h&gt;</cell></row><row><cell>CUmodule module;</cell></row><row><cell>CUfunction kernel_func;</cell></row><row><cell>// ...</cell></row></table><note><p>cuModuleGetFunction(&amp;kernel_func, module, "kernel");</p></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://github.com/chsasank/llama.lisp" />
		<title level="m">The Llama.lisp Compiler Framework</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Letters to the editor: go to statement considered harmful</title>
		<author>
			<persName><forename type="first">Edsger</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="147" to="148" />
			<date type="published" when="1968">1968</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">LLVM: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International symposium on code generation and optimization</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2004">2004. 2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The C programming language</title>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">W</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Domain-Specific Program Generation: International Seminar</title>
		<author>
			<persName><forename type="first">Walid</forename><surname>Taha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">March 23-28, 2003. 2004</date>
			<publisher>Springer</publisher>
			<pubPlace>Dagstuhl Castle, Germany; Berlin, Heidelberg; Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
	<note>Revised Papers</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Quasiquotation in Lisp</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Bawden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PEPM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Numba: A llvm-based python jit compiler</title>
		<author>
			<persName><forename type="first">Siu</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Antoine</forename><surname>Kwan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stanley</forename><surname>Pitrou</surname></persName>
		</author>
		<author>
			<persName><surname>Seibert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second Workshop on the LLVM Compiler Infrastructure in HPC</title>
		<meeting>the Second Workshop on the LLVM Compiler Infrastructure in HPC</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
