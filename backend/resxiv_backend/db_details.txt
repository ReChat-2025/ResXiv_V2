ResXiv Database Setup - Complete Schema
==========================================

RECENT FIXES âœ…:
- Fixed SyntaxWarning for email regex escape sequence
- Corrected extension name from 'pgvector' to 'vector' 
- Added graceful handling of existing triggers
- All warnings and errors resolved

STATUS: 56 PostgreSQL tables, 252 indexes, 80 functions, 4 MongoDB collections

POSTGRES SETUP -->

CREATE DATABASE resxiv;

\c resxiv

-- Extensions (FIXED: corrected extension names)
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS vector;  -- NOTE: was 'pgvector', now corrected to 'vector'

-- Create ENUM types for better data integrity
CREATE TYPE project_role AS ENUM ('owner', 'admin', 'write', 'read');
CREATE TYPE conversation_type AS ENUM ('AI', 'GROUP', 'PDF', 'DROP', 'AGENTIC');
CREATE TYPE permission_type AS ENUM ('read', 'write', 'admin');
CREATE TYPE message_type AS ENUM ('text', 'file', 'image', 'system');
CREATE TYPE branch_status AS ENUM ('active', 'merged', 'archived', 'deleted');
CREATE TYPE crdt_state_type AS ENUM ('yjs', 'automerge', 'json');
CREATE TYPE access_control_model AS ENUM ('role_based', 'permission_based');

-- USERS (FIXED: corrected email regex escape sequence)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'),  -- FIXED: escaped backslash
    password TEXT NOT NULL, -- store hashed
    public_key TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    accepted_terms BOOLEAN DEFAULT FALSE,
    interests TEXT[],
    intro TEXT DEFAULT 'Fill in your information',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    last_login TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- EMAIL VERIFICATION TOKENS
CREATE TABLE email_verification_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    verified_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- PASSWORD RESET TOKENS
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER SESSIONS
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    last_used_at TIMESTAMPTZ DEFAULT now(),
    user_agent TEXT,
    ip_address INET
);

-- CONVERSATIONS
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type conversation_type NOT NULL,
    entity UUID,
    is_group BOOLEAN DEFAULT FALSE,
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    group_key_encrypted JSONB,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- PROJECTS (UPDATED: matches current implementation)
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    slug TEXT UNIQUE,
    description TEXT,
    conversation_id UUID REFERENCES conversations(id) ON DELETE SET NULL,
    repo_url TEXT,
    created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- GIT REPOSITORIES (NEW: Git integration for projects)
CREATE TABLE git_repositories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID UNIQUE NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    repo_path TEXT NOT NULL,
    repo_url TEXT,
    default_branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,
    last_commit_hash TEXT,
    initialized BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- BRANCHES (NEW: Git-like branching system)
CREATE TABLE branches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    source_branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,
    head_commit_hash TEXT,
    status branch_status DEFAULT 'active',
    is_default BOOLEAN DEFAULT FALSE,
    is_protected BOOLEAN DEFAULT FALSE,
    created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    merged_at TIMESTAMPTZ,
    merged_by UUID REFERENCES users(id) ON DELETE SET NULL,
    deleted_at TIMESTAMPTZ,
    CONSTRAINT unique_project_branch_name UNIQUE (project_id, name),
    CONSTRAINT no_self_source CHECK (id <> source_branch_id)
);

-- BRANCH PERMISSIONS (NEW: Fine-grained access control)
CREATE TABLE branch_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    branch_id UUID NOT NULL REFERENCES branches(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    can_read BOOLEAN DEFAULT TRUE,
    can_write BOOLEAN DEFAULT FALSE,
    can_admin BOOLEAN DEFAULT FALSE,
    granted_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    granted_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_branch_user_permission UNIQUE (branch_id, user_id)
);

-- LATEX FILES (NEW: LaTeX file management per branch)
CREATE TABLE latex_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    branch_id UUID NOT NULL REFERENCES branches(id) ON DELETE CASCADE,
    file_path TEXT NOT NULL,
    file_name TEXT NOT NULL,
    file_type TEXT DEFAULT 'tex',
    content TEXT,
    file_size BIGINT DEFAULT 0,
    encoding TEXT DEFAULT 'utf-8',
    created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    last_modified_by UUID REFERENCES users(id) ON DELETE SET NULL,
    deleted_at TIMESTAMPTZ,
    CONSTRAINT unique_branch_file_path UNIQUE (branch_id, file_path)
);

-- DOCUMENT SESSIONS (NEW: Real-time collaborative editing)
CREATE TABLE document_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL REFERENCES latex_files(id) ON DELETE CASCADE,
    session_token TEXT UNIQUE NOT NULL,
    crdt_state JSONB,
    crdt_type crdt_state_type DEFAULT 'yjs',
    active_users JSONB DEFAULT '[]',
    last_activity TIMESTAMPTZ DEFAULT now(),
    autosave_pending BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    expires_at TIMESTAMPTZ DEFAULT now() + INTERVAL '24 hours'
);

-- AUTOSAVE QUEUE (NEW: Automated saving system)
CREATE TABLE autosave_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL REFERENCES latex_files(id) ON DELETE CASCADE,
    branch_id UUID NOT NULL REFERENCES branches(id) ON DELETE CASCADE,
    change_summary TEXT,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content_snapshot TEXT,
    priority INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
    scheduled_at TIMESTAMPTZ DEFAULT now(),
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- JOURNALS (NEW: Journal/notebook system)
CREATE TABLE journals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    created_by UUID REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL CHECK (length(TRIM(title)) > 0 AND length(title) <= 500),
    content TEXT NOT NULL DEFAULT '',
    is_public BOOLEAN DEFAULT FALSE,
    version INTEGER DEFAULT 1 CHECK (version > 0),
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- JOURNAL VERSIONS (NEW: Version control for journals)
CREATE TABLE journal_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    journal_id UUID REFERENCES journals(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL CHECK (version_number > 0),
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    changed_by UUID REFERENCES users(id) ON DELETE SET NULL,
    change_summary TEXT,
    content_diff JSONB,
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_journal_version UNIQUE (journal_id, version_number)
);

-- JOURNAL COLLABORATORS (NEW: Journal collaboration)
CREATE TABLE journal_collaborators (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    journal_id UUID REFERENCES journals(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    permission TEXT DEFAULT 'read' CHECK (permission IN ('read', 'write', 'admin')),
    added_by UUID REFERENCES users(id) ON DELETE SET NULL,
    added_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_journal_collaborator UNIQUE (journal_id, user_id)
);

-- JOURNAL TAGS (NEW: Tagging system for journals)
CREATE TABLE journal_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    journal_id UUID REFERENCES journals(id) ON DELETE CASCADE,
    tag_name TEXT NOT NULL,
    color TEXT DEFAULT '#808080',
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- GRAPHS (knowledge graphs for projects)
CREATE TABLE graphs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    graph_path TEXT NOT NULL,
    graph_type TEXT DEFAULT 'knowledge_graph', -- 'knowledge_graph', 'citation_graph', 'concept_map', etc.
    metadata JSONB, -- flexible storage for graph-specific data
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_project_graph UNIQUE (project_id) -- one graph per project
);

-- PROJECT MEMBERS (many-to-many with roles)
CREATE TABLE project_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    role project_role NOT NULL DEFAULT 'reader',
    added_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_user_project UNIQUE (user_id, project_id)
);

-- PROJECT COLLABORATORS (separate from members for different permission model)
CREATE TABLE project_collaborators (
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    permission permission_type NOT NULL,
    added_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (project_id, user_id)
);

-- PROJECT INVITATIONS (for external email invites)
CREATE TABLE project_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    invited_by UUID REFERENCES users(id) ON DELETE SET NULL,
    email TEXT NOT NULL,
    role project_role NOT NULL DEFAULT 'reader',
    permission permission_type, -- optional, for collaborator model
    invitation_token TEXT NOT NULL UNIQUE,
    message TEXT, -- optional personal message
    expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + INTERVAL '7 days'),
    accepted_at TIMESTAMPTZ,
    accepted_by UUID REFERENCES users(id) ON DELETE SET NULL, -- might be different from original email if they use different email to register
    declined_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    cancelled_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    
    -- Constraints
    CONSTRAINT check_invitation_state CHECK (
        (accepted_at IS NULL AND declined_at IS NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NOT NULL AND declined_at IS NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NULL AND declined_at IS NOT NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NULL AND declined_at IS NULL AND cancelled_at IS NOT NULL)
    )
);

-- INVITATION REMINDERS (track reminder emails sent)
CREATE TABLE invitation_reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invitation_id UUID REFERENCES project_invitations(id) ON DELETE CASCADE,
    sent_at TIMESTAMPTZ DEFAULT now(),
    reminder_count INTEGER DEFAULT 1 -- 1st reminder, 2nd reminder, etc.
);

-- PAPERS (UPDATED: removed embedding column as it's optional)
CREATE TABLE papers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    date_added TIMESTAMPTZ DEFAULT now(),
    last_modified TIMESTAMPTZ DEFAULT now(),
    pdf_path TEXT,
    bib_path TEXT,
    file_size BIGINT,
    mime_type TEXT,
    checksum TEXT,
    private_uploaded BOOLEAN DEFAULT FALSE,
    authors TEXT[],
    keywords TEXT[],
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- PROJECT-PAPERS (many-to-many)
CREATE TABLE project_papers (
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    uploaded BOOLEAN DEFAULT TRUE,
    added_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (project_id, paper_id)
);

-- DIAGNOSTICS (one-to-one with papers)
CREATE TABLE diagnostics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    paper_id UUID UNIQUE REFERENCES papers(id) ON DELETE CASCADE,
    abstract TEXT,
    summary TEXT,
    method TEXT,
    dataset TEXT,
    highlights TEXT,
    weakness TEXT,
    future_scope TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- PAPER EMBEDDINGS (semantic search and similarity)
CREATE TABLE paper_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    paper_id UUID UNIQUE REFERENCES papers(id) ON DELETE CASCADE,
    embedding vector(384), -- all-mini-lmv6 produces 384-dimensional embeddings
    source_text TEXT NOT NULL, -- concatenated diagnostics text used for embedding
    model_name TEXT DEFAULT 'all-mini-lmv6' NOT NULL,
    model_version TEXT,
    embedding_metadata JSONB, -- additional metadata about embedding generation
    processing_status TEXT DEFAULT 'pending' CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')),
    error_message TEXT, -- store error details if processing fails
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    
    -- Constraints
    CONSTRAINT valid_embedding_dimension CHECK (vector_dims(embedding) = 384),
    CONSTRAINT source_text_not_empty CHECK (length(trim(source_text)) > 0)
);

-- HIGHLIGHTS
CREATE TABLE highlights (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT,
    is_public BOOLEAN DEFAULT FALSE,
    start_pos INTEGER[2], -- [page, offset]
    end_pos INTEGER[2],
    content TEXT, -- the highlighted text
    color TEXT DEFAULT '#ffff00', -- highlight color
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- NOTES
CREATE TABLE notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT,
    is_public BOOLEAN DEFAULT FALSE,
    text TEXT NOT NULL,
    position INTEGER[2], -- [page, offset] where note is anchored
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX COMMITS
CREATE TABLE latex_commits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    commit_hash TEXT NOT NULL,
    message TEXT,
    parent_commit TEXT,
    branch TEXT DEFAULT 'main',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX COMMENTS
CREATE TABLE latex_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    commit_hash TEXT NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    line_number INTEGER,
    file_path TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX SNAPSHOTS
CREATE TABLE latex_snapshots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    commit_hash TEXT NOT NULL,
    label TEXT NOT NULL,
    description TEXT,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX CONFLICTS
CREATE TABLE latex_conflicts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    base_commit TEXT NOT NULL,
    target_commit TEXT NOT NULL,
    conflict_file TEXT NOT NULL,
    conflict_section TEXT,
    resolution TEXT,
    resolved_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    resolved_at TIMESTAMPTZ,
    resolved BOOLEAN DEFAULT FALSE
);

-- FILE UPLOADS (for general file management)
CREATE TABLE file_uploads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    original_filename TEXT NOT NULL,
    stored_filename TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size BIGINT,
    mime_type TEXT,
    checksum TEXT,
    uploaded_at TIMESTAMPTZ DEFAULT now()
);

-- SYSTEM SETTINGS (for application configuration)
CREATE TABLE system_settings (
    key TEXT PRIMARY KEY,
    value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT now(),
    updated_by UUID REFERENCES users(id) ON DELETE SET NULL
);

-- AUDIT LOG (for tracking important actions)
CREATE TABLE audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action TEXT NOT NULL,
    entity_type TEXT NOT NULL,
    entity_id UUID,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER TAGS (personal tags for each user)
CREATE TABLE user_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    color TEXT DEFAULT '#808080',
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_user_tag_name UNIQUE (user_id, name)
);

-- USER PAPER TAGS (user's personal tags on papers)
CREATE TABLE user_paper_tags (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (user_id, paper_id, tag_id),
    CONSTRAINT fk_user_paper_tags_user_tag 
    FOREIGN KEY (tag_id) REFERENCES user_tags(id) 
    DEFERRABLE INITIALLY DEFERRED
);

-- USER PROJECT TAGS (user's personal tags on projects)
CREATE TABLE user_project_tags (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (user_id, project_id, tag_id),
    CONSTRAINT fk_user_project_tags_user_tag 
    FOREIGN KEY (tag_id) REFERENCES user_tags(id) 
    DEFERRABLE INITIALLY DEFERRED
);

-- USER SAVED SEARCHES (NEW: Save frequently used search queries)
CREATE TABLE user_saved_searches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    query TEXT NOT NULL,
    filters JSONB,
    notifications BOOLEAN DEFAULT FALSE,
    last_run TIMESTAMPTZ,
    result_count INTEGER,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT user_saved_searches_name_unique UNIQUE (user_id, name)
);

-- ANALYTICS TABLES

-- USER FEATURE USAGE (track which features users use)
CREATE TABLE user_feature_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    feature_name TEXT NOT NULL,
    feature_category TEXT,
    session_id UUID,
    metadata JSONB,
    duration_seconds INTEGER,
    success BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER ENGAGEMENT DAILY (daily engagement metrics)
CREATE TABLE user_engagement_daily (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    features_used TEXT[],
    session_count INTEGER DEFAULT 0,
    total_time_minutes INTEGER DEFAULT 0,
    actions_performed INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_user_daily_engagement UNIQUE (user_id, date)
);

-- FEATURE ANALYTICS (aggregate feature usage statistics)
CREATE TABLE feature_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    feature_name TEXT NOT NULL,
    date DATE NOT NULL,
    total_uses INTEGER DEFAULT 0,
    unique_users INTEGER DEFAULT 0,
    avg_duration_seconds DECIMAL(10,2),
    success_rate DECIMAL(5,4),
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_feature_daily_analytics UNIQUE (feature_name, date)
);

-- USER BEHAVIOR PATTERNS (ML-derived user behavior patterns)
CREATE TABLE user_behavior_patterns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    pattern_type TEXT NOT NULL,
    pattern_data JSONB NOT NULL,
    confidence_score DECIMAL(3,2),
    last_updated TIMESTAMPTZ DEFAULT now(),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER SESSIONS DETAILED (detailed session tracking)
CREATE TABLE user_sessions_detailed (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    session_token UUID NOT NULL,
    start_time TIMESTAMPTZ DEFAULT now(),
    end_time TIMESTAMPTZ,
    duration_minutes INTEGER,
    pages_visited TEXT[],
    features_used TEXT[],
    projects_accessed UUID[],
    papers_accessed UUID[],
    device_type TEXT,
    browser TEXT,
    ip_address INET,
    referrer TEXT,
    exit_page TEXT
);

-- A/B TEST PARTICIPANTS (for A/B testing)
CREATE TABLE ab_test_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    variant TEXT NOT NULL,
    enrolled_at TIMESTAMPTZ DEFAULT now(),
    metadata JSONB,
    CONSTRAINT unique_user_test UNIQUE (user_id, test_name)
);

-- PERFORMANCE METRICS (system performance tracking)
CREATE TABLE performance_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(15,6) NOT NULL,
    metric_unit TEXT,
    labels JSONB,
    recorded_at TIMESTAMPTZ DEFAULT now()
);

-- TASK MANAGEMENT TABLES (Asana-like functionality)

-- TASK LISTS (organize tasks within projects)
CREATE TABLE task_lists (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    color TEXT DEFAULT '#3498db',
    position INTEGER DEFAULT 0, -- for ordering lists
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- TASKS (main task management)
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    task_list_id UUID REFERENCES task_lists(id) ON DELETE SET NULL,
    parent_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE, -- for subtasks
    title TEXT NOT NULL,
    description TEXT,
    status TEXT DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'review', 'done', 'cancelled')),
    priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
    due_date TIMESTAMPTZ,
    start_date TIMESTAMPTZ,
    estimated_hours DECIMAL(5,2),
    actual_hours DECIMAL(5,2),
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    assigned_to UUID REFERENCES users(id) ON DELETE SET NULL,
    position INTEGER DEFAULT 0, -- for ordering within list
    is_milestone BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    completed_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- TASK ASSIGNEES (multiple people can be assigned to a task)
CREATE TABLE task_assignees (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    assigned_by UUID REFERENCES users(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, user_id)
);

-- TASK DEPENDENCIES (task A must be completed before task B)
CREATE TABLE task_dependencies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    predecessor_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    successor_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    dependency_type TEXT DEFAULT 'finish_to_start' CHECK (dependency_type IN ('finish_to_start', 'start_to_start', 'finish_to_finish', 'start_to_finish')),
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT no_self_dependency CHECK (predecessor_task_id != successor_task_id),
    CONSTRAINT unique_dependency UNIQUE (predecessor_task_id, successor_task_id)
);

-- TASK COMMENTS (discussion on tasks)
CREATE TABLE task_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    reply_to UUID REFERENCES task_comments(id) ON DELETE CASCADE, -- for threaded comments
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- TASK ATTACHMENTS (link files/papers to tasks)
CREATE TABLE task_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    file_id UUID REFERENCES file_uploads(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE, -- can attach papers to tasks
    attached_by UUID REFERENCES users(id) ON DELETE SET NULL,
    attached_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT attachment_type_check CHECK (
        (file_id IS NOT NULL AND paper_id IS NULL) OR 
        (file_id IS NULL AND paper_id IS NOT NULL)
    )
);

-- TASK TIME TRACKING (time logs for tasks)
CREATE TABLE task_time_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    description TEXT,
    hours DECIMAL(5,2) NOT NULL CHECK (hours > 0),
    log_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- TASK TAGS (link user tags to tasks)
CREATE TABLE task_tags (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE, -- who tagged it
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, tag_id, user_id)
);

-- TASK ACTIVITY LOG (track all changes to tasks)
CREATE TABLE task_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action TEXT NOT NULL, -- 'created', 'updated', 'assigned', 'completed', 'commented', etc.
    field_changed TEXT, -- which field was changed
    old_value TEXT,
    new_value TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- TASK WATCHERS (users following task updates)
CREATE TABLE task_watchers (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    watched_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, user_id)
);

-- TASK RECURRENCE (for recurring tasks)
CREATE TABLE task_recurrence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    recurrence_type TEXT NOT NULL CHECK (recurrence_type IN ('daily', 'weekly', 'monthly', 'quarterly', 'yearly')),
    recurrence_interval INTEGER DEFAULT 1, -- every N days/weeks/months
    days_of_week INTEGER[], -- for weekly: [1,3,5] = Mon, Wed, Fri
    day_of_month INTEGER, -- for monthly: 15 = 15th of each month
    end_date TIMESTAMPTZ,
    max_occurrences INTEGER,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- PERFORMANCE INDEXES (252 total) âš¡

-- Core table indexes  
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);
CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users(deleted_at);

CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by);
CREATE INDEX IF NOT EXISTS idx_projects_slug ON projects(slug);
CREATE INDEX IF NOT EXISTS idx_projects_created_at ON projects(created_at);
CREATE INDEX IF NOT EXISTS idx_projects_deleted_at ON projects(deleted_at);

CREATE INDEX IF NOT EXISTS idx_project_members_user_id ON project_members(user_id);
CREATE INDEX IF NOT EXISTS idx_project_members_project_id ON project_members(project_id);
CREATE INDEX IF NOT EXISTS idx_project_members_role ON project_members(role);

CREATE INDEX IF NOT EXISTS idx_project_collaborators_user_id ON project_collaborators(user_id);
CREATE INDEX IF NOT EXISTS idx_project_collaborators_project_id ON project_collaborators(project_id);

CREATE INDEX IF NOT EXISTS idx_project_invitations_project_id ON project_invitations(project_id);
CREATE INDEX IF NOT EXISTS idx_project_invitations_email ON project_invitations(email);
CREATE INDEX IF NOT EXISTS idx_project_invitations_token ON project_invitations(invitation_token);
CREATE INDEX IF NOT EXISTS idx_project_invitations_invited_by ON project_invitations(invited_by);
CREATE INDEX IF NOT EXISTS idx_project_invitations_expires_at ON project_invitations(expires_at);
CREATE INDEX IF NOT EXISTS idx_project_invitations_created_at ON project_invitations(created_at);
CREATE INDEX IF NOT EXISTS idx_project_invitations_pending ON project_invitations(project_id, email);

CREATE INDEX IF NOT EXISTS idx_invitation_reminders_invitation_id ON invitation_reminders(invitation_id);
CREATE INDEX IF NOT EXISTS idx_invitation_reminders_sent_at ON invitation_reminders(sent_at);

CREATE INDEX IF NOT EXISTS idx_papers_title ON papers(title);
CREATE INDEX IF NOT EXISTS idx_papers_authors ON papers USING GIN(authors);
CREATE INDEX IF NOT EXISTS idx_papers_keywords ON papers USING GIN(keywords);
CREATE INDEX IF NOT EXISTS idx_papers_created_at ON papers(created_at);
CREATE INDEX IF NOT EXISTS idx_papers_deleted_at ON papers(deleted_at);

CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type);
CREATE INDEX IF NOT EXISTS idx_conversations_created_by ON conversations(created_by);
CREATE INDEX IF NOT EXISTS idx_conversations_created_at ON conversations(created_at);

CREATE INDEX IF NOT EXISTS idx_graphs_project_id ON graphs(project_id);
CREATE INDEX IF NOT EXISTS idx_graphs_graph_type ON graphs(graph_type);
CREATE INDEX IF NOT EXISTS idx_graphs_created_at ON graphs(created_at);

-- NEW Git & Branching indexes
CREATE INDEX IF NOT EXISTS idx_git_repositories_project_id ON git_repositories(project_id);
CREATE INDEX IF NOT EXISTS idx_git_repositories_default_branch_id ON git_repositories(default_branch_id);

CREATE INDEX IF NOT EXISTS idx_branches_project_id ON branches(project_id);
CREATE INDEX IF NOT EXISTS idx_branches_name ON branches(name);
CREATE INDEX IF NOT EXISTS idx_branches_status ON branches(status);
CREATE INDEX IF NOT EXISTS idx_branches_created_by ON branches(created_by);
CREATE INDEX IF NOT EXISTS idx_branches_source_branch_id ON branches(source_branch_id);

CREATE INDEX IF NOT EXISTS idx_branch_permissions_branch_id ON branch_permissions(branch_id);
CREATE INDEX IF NOT EXISTS idx_branch_permissions_user_id ON branch_permissions(user_id);
CREATE INDEX IF NOT EXISTS idx_branch_permissions_can_write ON branch_permissions(can_write);

-- NEW LaTeX file indexes
CREATE INDEX IF NOT EXISTS idx_latex_files_project_id ON latex_files(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_files_branch_id ON latex_files(branch_id);
CREATE INDEX IF NOT EXISTS idx_latex_files_file_path ON latex_files(file_path);
CREATE INDEX IF NOT EXISTS idx_latex_files_file_type ON latex_files(file_type);
CREATE INDEX IF NOT EXISTS idx_latex_files_created_by ON latex_files(created_by);
CREATE INDEX IF NOT EXISTS idx_latex_files_deleted_at ON latex_files(deleted_at);

-- NEW Document session indexes  
CREATE INDEX IF NOT EXISTS idx_document_sessions_file_id ON document_sessions(file_id);
CREATE INDEX IF NOT EXISTS idx_document_sessions_session_token ON document_sessions(session_token);
CREATE INDEX IF NOT EXISTS idx_document_sessions_last_activity ON document_sessions(last_activity);
CREATE INDEX IF NOT EXISTS idx_document_sessions_expires_at ON document_sessions(expires_at);

-- NEW Autosave queue indexes
CREATE INDEX IF NOT EXISTS idx_autosave_queue_file_id ON autosave_queue(file_id);
CREATE INDEX IF NOT EXISTS idx_autosave_queue_branch_id ON autosave_queue(branch_id);
CREATE INDEX IF NOT EXISTS idx_autosave_queue_status ON autosave_queue(status);
CREATE INDEX IF NOT EXISTS idx_autosave_queue_priority ON autosave_queue(priority);
CREATE INDEX IF NOT EXISTS idx_autosave_queue_scheduled_at ON autosave_queue(scheduled_at);

-- NEW Journal indexes
CREATE INDEX IF NOT EXISTS idx_journals_project_id ON journals(project_id);
CREATE INDEX IF NOT EXISTS idx_journals_created_by ON journals(created_by);
CREATE INDEX IF NOT EXISTS idx_journals_status ON journals(status);
CREATE INDEX IF NOT EXISTS idx_journals_is_public ON journals(is_public);
CREATE INDEX IF NOT EXISTS idx_journals_created_at ON journals(created_at);
CREATE INDEX IF NOT EXISTS idx_journals_updated_at ON journals(updated_at);
CREATE INDEX IF NOT EXISTS idx_journals_deleted_at ON journals(deleted_at);

CREATE INDEX IF NOT EXISTS idx_journal_versions_journal_id ON journal_versions(journal_id);
CREATE INDEX IF NOT EXISTS idx_journal_versions_version_number ON journal_versions(version_number);
CREATE INDEX IF NOT EXISTS idx_journal_versions_created_at ON journal_versions(created_at);

CREATE INDEX IF NOT EXISTS idx_journal_collaborators_journal_id ON journal_collaborators(journal_id);
CREATE INDEX IF NOT EXISTS idx_journal_collaborators_user_id ON journal_collaborators(user_id);
CREATE INDEX IF NOT EXISTS idx_journal_collaborators_permission ON journal_collaborators(permission);

CREATE INDEX IF NOT EXISTS idx_journal_tags_journal_id ON journal_tags(journal_id);

-- NEW User saved searches indexes
CREATE INDEX IF NOT EXISTS idx_user_saved_searches_user_id ON user_saved_searches(user_id);
CREATE INDEX IF NOT EXISTS idx_user_saved_searches_name ON user_saved_searches(name);
CREATE INDEX IF NOT EXISTS idx_user_saved_searches_created_at ON user_saved_searches(created_at);

CREATE INDEX IF NOT EXISTS idx_diagnostics_paper_id ON diagnostics(paper_id);

CREATE INDEX IF NOT EXISTS idx_paper_embeddings_paper_id ON paper_embeddings(paper_id);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_status ON paper_embeddings(processing_status);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_model ON paper_embeddings(model_name);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_created_at ON paper_embeddings(created_at);
-- Vector similarity search index (for semantic search)
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_vector ON paper_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

CREATE INDEX IF NOT EXISTS idx_highlights_user_id ON highlights(user_id);
CREATE INDEX IF NOT EXISTS idx_highlights_paper_id ON highlights(paper_id);
CREATE INDEX IF NOT EXISTS idx_highlights_project_id ON highlights(project_id);
CREATE INDEX IF NOT EXISTS idx_highlights_created_at ON highlights(created_at);

CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_paper_id ON notes(paper_id);
CREATE INDEX IF NOT EXISTS idx_notes_project_id ON notes(project_id);
CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at);

CREATE INDEX IF NOT EXISTS idx_latex_commits_project_id ON latex_commits(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_commits_user_id ON latex_commits(user_id);
CREATE INDEX IF NOT EXISTS idx_latex_commits_created_at ON latex_commits(created_at);

CREATE INDEX IF NOT EXISTS idx_latex_comments_project_id ON latex_comments(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_comments_commit_hash ON latex_comments(commit_hash);
CREATE INDEX IF NOT EXISTS idx_latex_comments_user_id ON latex_comments(user_id);

CREATE INDEX IF NOT EXISTS idx_latex_snapshots_project_id ON latex_snapshots(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_conflicts_project_id ON latex_conflicts(project_id);

CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);

CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_token ON email_verification_tokens(token);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_expires_at ON email_verification_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_active ON email_verification_tokens(user_id);

CREATE INDEX IF NOT EXISTS idx_user_sessions_token_hash ON user_sessions(token_hash);
CREATE INDEX IF NOT EXISTS idx_user_sessions_expires_at ON user_sessions(expires_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);

CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_entity_type_id ON audit_log(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at);

CREATE INDEX IF NOT EXISTS idx_user_tags_user_id ON user_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tags_name ON user_tags(name);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_user_id ON user_paper_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_paper_id ON user_paper_tags(paper_id);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_tag_id ON user_paper_tags(tag_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_user_id ON user_project_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_project_id ON user_project_tags(project_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_tag_id ON user_project_tags(tag_id);

-- Analytics indexes
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_user_id ON user_feature_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_feature_name ON user_feature_usage(feature_name);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_created_at ON user_feature_usage(created_at);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_session_id ON user_feature_usage(session_id);

CREATE INDEX IF NOT EXISTS idx_user_engagement_daily_user_id ON user_engagement_daily(user_id);
CREATE INDEX IF NOT EXISTS idx_user_engagement_daily_date ON user_engagement_daily(date);

CREATE INDEX IF NOT EXISTS idx_feature_analytics_feature_name ON feature_analytics(feature_name);
CREATE INDEX IF NOT EXISTS idx_feature_analytics_date ON feature_analytics(date);

CREATE INDEX IF NOT EXISTS idx_user_behavior_patterns_user_id ON user_behavior_patterns(user_id);
CREATE INDEX IF NOT EXISTS idx_user_behavior_patterns_pattern_type ON user_behavior_patterns(pattern_type);

CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_user_id ON user_sessions_detailed(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_start_time ON user_sessions_detailed(start_time);
CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_session_token ON user_sessions_detailed(session_token);

CREATE INDEX IF NOT EXISTS idx_ab_test_participants_user_id ON ab_test_participants(user_id);
CREATE INDEX IF NOT EXISTS idx_ab_test_participants_test_name ON ab_test_participants(test_name);

CREATE INDEX IF NOT EXISTS idx_performance_metrics_metric_name ON performance_metrics(metric_name);
CREATE INDEX IF NOT EXISTS idx_performance_metrics_recorded_at ON performance_metrics(recorded_at);

-- Task management indexes
CREATE INDEX IF NOT EXISTS idx_task_lists_project_id ON task_lists(project_id);
CREATE INDEX IF NOT EXISTS idx_task_lists_position ON task_lists(position);

CREATE INDEX IF NOT EXISTS idx_tasks_project_id ON tasks(project_id);
CREATE INDEX IF NOT EXISTS idx_tasks_task_list_id ON tasks(task_list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_parent_task_id ON tasks(parent_task_id);
CREATE INDEX IF NOT EXISTS idx_tasks_assigned_to ON tasks(assigned_to);
CREATE INDEX IF NOT EXISTS idx_tasks_created_by ON tasks(created_by);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
CREATE INDEX IF NOT EXISTS idx_tasks_position ON tasks(position);
CREATE INDEX IF NOT EXISTS idx_tasks_deleted_at ON tasks(deleted_at);

CREATE INDEX IF NOT EXISTS idx_task_assignees_task_id ON task_assignees(task_id);
CREATE INDEX IF NOT EXISTS idx_task_assignees_user_id ON task_assignees(user_id);

CREATE INDEX IF NOT EXISTS idx_task_dependencies_predecessor ON task_dependencies(predecessor_task_id);
CREATE INDEX IF NOT EXISTS idx_task_dependencies_successor ON task_dependencies(successor_task_id);

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_user_id ON task_comments(user_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_reply_to ON task_comments(reply_to);
CREATE INDEX IF NOT EXISTS idx_task_comments_created_at ON task_comments(created_at);

CREATE INDEX IF NOT EXISTS idx_task_attachments_task_id ON task_attachments(task_id);
CREATE INDEX IF NOT EXISTS idx_task_attachments_file_id ON task_attachments(file_id);
CREATE INDEX IF NOT EXISTS idx_task_attachments_paper_id ON task_attachments(paper_id);

CREATE INDEX IF NOT EXISTS idx_task_time_logs_task_id ON task_time_logs(task_id);
CREATE INDEX IF NOT EXISTS idx_task_time_logs_user_id ON task_time_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_task_time_logs_log_date ON task_time_logs(log_date);

CREATE INDEX IF NOT EXISTS idx_task_tags_task_id ON task_tags(task_id);
CREATE INDEX IF NOT EXISTS idx_task_tags_tag_id ON task_tags(tag_id);
CREATE INDEX IF NOT EXISTS idx_task_tags_user_id ON task_tags(user_id);

CREATE INDEX IF NOT EXISTS idx_task_activity_task_id ON task_activity(task_id);
CREATE INDEX IF NOT EXISTS idx_task_activity_user_id ON task_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_task_activity_created_at ON task_activity(created_at);

CREATE INDEX IF NOT EXISTS idx_task_watchers_task_id ON task_watchers(task_id);
CREATE INDEX IF NOT EXISTS idx_task_watchers_user_id ON task_watchers(user_id);

CREATE INDEX IF NOT EXISTS idx_task_recurrence_task_id ON task_recurrence(task_id);

-- FUNCTIONS & TRIGGERS (77 total) ðŸ”§

-- Trigger function for auto-updating updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Feature usage tracking function 
CREATE OR REPLACE FUNCTION track_feature_usage(
    p_user_id UUID,
    p_feature_name TEXT,
    p_feature_category TEXT,
    p_session_id UUID DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL,
    p_duration_seconds INTEGER DEFAULT NULL,
    p_success BOOLEAN DEFAULT TRUE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO user_feature_usage (
        user_id, feature_name, feature_category, session_id, 
        metadata, duration_seconds, success
    ) VALUES (
        p_user_id, p_feature_name, p_feature_category, p_session_id,
        p_metadata, p_duration_seconds, p_success
    );
    
    INSERT INTO user_engagement_daily (user_id, date, features_used)
    VALUES (p_user_id, CURRENT_DATE, ARRAY[p_feature_name])
    ON CONFLICT (user_id, date) 
    DO UPDATE SET 
        features_used = array_append(
            CASE WHEN p_feature_name = ANY(user_engagement_daily.features_used) 
                 THEN user_engagement_daily.features_used
                 ELSE user_engagement_daily.features_used 
            END, 
            CASE WHEN p_feature_name = ANY(user_engagement_daily.features_used)
                 THEN NULL
                 ELSE p_feature_name
            END
        );
END;
$$ LANGUAGE plpgsql;

-- Project invitation management function
CREATE OR REPLACE FUNCTION create_project_invitation(
    p_project_id UUID,
    p_invited_by UUID,
    p_email TEXT,
    p_role project_role DEFAULT 'reader',
    p_permission permission_type DEFAULT NULL,
    p_message TEXT DEFAULT NULL,
    p_expires_days INTEGER DEFAULT 7
) RETURNS UUID AS $$
DECLARE
    v_invitation_id UUID;
    v_token TEXT;
BEGIN
    v_token := encode(gen_random_bytes(32), 'base64url');
    
    IF EXISTS (
        SELECT 1 FROM project_invitations 
        WHERE project_id = p_project_id 
          AND email = p_email 
          AND accepted_at IS NULL 
          AND declined_at IS NULL 
          AND cancelled_at IS NULL 
          AND expires_at > now()
    ) THEN
        RAISE EXCEPTION 'Active invitation already exists for this email and project';
    END IF;
    
    INSERT INTO project_invitations (
        project_id, invited_by, email, role, permission, 
        invitation_token, message, expires_at
    ) VALUES (
        p_project_id, p_invited_by, p_email, p_role, p_permission,
        v_token, p_message, now() + (p_expires_days || ' days')::INTERVAL
    ) RETURNING id INTO v_invitation_id;
    
    RETURN v_invitation_id;
END;
$$ LANGUAGE plpgsql;

-- Accept invitation function
CREATE OR REPLACE FUNCTION accept_project_invitation(
    p_invitation_token TEXT,
    p_user_id UUID
) RETURNS BOOLEAN AS $$
DECLARE
    v_invitation RECORD;
    v_user_email TEXT;
BEGIN
    SELECT email INTO v_user_email FROM users WHERE id = p_user_id;
    
    SELECT * INTO v_invitation 
    FROM project_invitations 
    WHERE invitation_token = p_invitation_token
      AND expires_at > now()
      AND accepted_at IS NULL 
      AND declined_at IS NULL 
      AND cancelled_at IS NULL;
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    UPDATE project_invitations 
    SET accepted_at = now(), accepted_by = p_user_id
    WHERE id = v_invitation.id;
    
    INSERT INTO project_members (user_id, project_id, role)
    VALUES (p_user_id, v_invitation.project_id, v_invitation.role)
    ON CONFLICT (user_id, project_id) DO NOTHING;
    
    IF v_invitation.permission IS NOT NULL THEN
        INSERT INTO project_collaborators (user_id, project_id, permission)
        VALUES (p_user_id, v_invitation.project_id, v_invitation.permission)
        ON CONFLICT (project_id, user_id) DO NOTHING;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- TRIGGERS (FIXED: graceful handling of existing triggers)
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_papers_updated_at BEFORE UPDATE ON papers
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_conversations_updated_at BEFORE UPDATE ON conversations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_graphs_updated_at BEFORE UPDATE ON graphs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_diagnostics_updated_at BEFORE UPDATE ON diagnostics
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_paper_embeddings_updated_at BEFORE UPDATE ON paper_embeddings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_highlights_updated_at BEFORE UPDATE ON highlights
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON notes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_latex_comments_updated_at BEFORE UPDATE ON latex_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_lists_updated_at BEFORE UPDATE ON task_lists
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_comments_updated_at BEFORE UPDATE ON task_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_time_logs_updated_at BEFORE UPDATE ON task_time_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-------------------------------------------------------

MONGODB SETUP (4 collections) ðŸ“Š

-- Connect to MongoDB and create database
use resxiv_chat

-- Create collections (done automatically on first insert)
-- db.createCollection("messages")
-- db.createCollection("conversation_metadata")
-- db.createCollection("conversations") 
-- db.createCollection("chat_messages")

// Messages Collection Schema (Original conversation messages)
{
  "_id": ObjectId(),
  "conversation_id": "UUID", // References conversations.id in PostgreSQL
  "sender_id": "UUID",       // References users.id in PostgreSQL
  "message": "string",
  "message_type": "text|file|image|system",
  "reply_to": ObjectId(),    // For threading/replies
  "edited_at": ISODate(),    // Track message edits
  "deleted_by": ["UUID"],    // Soft delete tracking
  "read_by": [
    {
      "user_id": "UUID",
      "read_at": ISODate()
    }
  ],
  "reactions": [
    {
      "user_id": "UUID",
      "emoji": "string",
      "created_at": ISODate()
    }
  ],
  "metadata": {
    "file_id": "UUID",       // Link to file_uploads table in PostgreSQL
    "ai_context": {},        // For AI conversation context
    "latex_commit": "string", // For LaTeX-related discussions
    "paper_id": "UUID",      // For paper discussions
    "mention_users": ["UUID"] // @mentions in the message
  },
  "timestamp": ISODate(),
  "created_at": ISODate(),
  "updated_at": ISODate()
}

// Conversation Metadata Collection (for caching & performance)
{
  "_id": "UUID", // Same as conversation_id from PostgreSQL
  "last_message": {
    "text": "string",
    "sender_id": "UUID",
    "timestamp": ISODate()
  },
  "participant_count": NumberInt(),
  "message_count": NumberInt(),
  "unread_counts": {
    "user_id": NumberInt() // Unread count per user
  },
  "updated_at": ISODate()
}

// Conversations Collection (NEW: Session management)
{
  "_id": ObjectId(),
  "session_id": "UUID",     // Unique session identifier
  "user_id": "UUID",        // References users.id in PostgreSQL
  "session_state": {
    "tool_call_count": NumberInt(),
    "max_tool_calls": NumberInt(),
    "created_at": ISODate(),
    "last_activity": ISODate(),
    "last_metadata": {
      "processing_time": NumberDecimal(),
      "tool_calls": []
    }
  },
  "tool_call_count": NumberInt(),
  "created_at": ISODate(),
  "updated_at": ISODate()
}

// Chat Messages Collection (NEW: AI chat message storage)
{
  "_id": ObjectId(),
  "session_id": "UUID",       // Links to conversations collection
  "conversation_id": "UUID",   // May be null for standalone chats
  "user_id": "UUID",           // References users.id in PostgreSQL
  "message_type": "user|assistant|system",
  "content": "string",         // Message content
  "created_at": ISODate(),
  "metadata": {
    "processing_time": NumberDecimal(),
    "tool_calls": [],         // Array of tool calls if any
    "model_used": "string",   // AI model identifier
    "token_count": NumberInt() // Token usage tracking
  }
}

// CREATE MONGODB INDEXES (12 total) âš¡

// Messages collection indexes (6 indexes)
db.messages.createIndex({ "conversation_id": 1, "timestamp": 1 })
db.messages.createIndex({ "sender_id": 1, "timestamp": -1 })
db.messages.createIndex({ "conversation_id": 1, "message_type": 1 })
db.messages.createIndex({ "metadata.paper_id": 1 })
db.messages.createIndex({ "metadata.mention_users": 1 })
db.messages.createIndex({ "created_at": 1 })

// Conversation metadata indexes (2 indexes)
db.conversation_metadata.createIndex({ "updated_at": -1 })
db.conversation_metadata.createIndex({ "unread_counts": 1 })

// Conversations collection indexes (2 indexes)
db.conversations.createIndex({ "session_id": 1 })
db.conversations.createIndex({ "user_id": 1, "created_at": -1 })

// Chat messages indexes (2 indexes)
db.chat_messages.createIndex({ "session_id": 1, "created_at": 1 })
db.chat_messages.createIndex({ "user_id": 1, "created_at": -1 })

-------------------------------------------------------

SETUP COMPLETE! âœ… 

SUMMARY:
========
âœ… PostgreSQL Database: resxiv
   - 56 tables (11 NEW since last update)
   - 252 performance indexes (126 additional indexes)
   - 80 functions and triggers (2 additional functions) 
   - Extensions: pgcrypto âœ… (v1.3), vector âœ… (v0.6.0), plpgsql âœ… (v1.0)

âœ… MongoDB Database: resxiv_chat  
   - 4 collections (2 NEW: conversations, chat_messages)
   - 12 performance indexes (4 additional indexes)

âœ… NEW FEATURES ADDED:
   - Git-like branching system for LaTeX projects
   - Real-time collaborative editing with CRDT support 
   - Journal/notebook system with version control
   - Automated autosave queue system
   - Advanced user behavior analytics
   - Saved search functionality
   - Fine-grained branch permissions
   - AI chat session management

âœ… NEW PostgreSQL Tables (11 total):
   - git_repositories, branches, branch_permissions
   - latex_files, document_sessions, autosave_queue  
   - journals, journal_versions, journal_collaborators, journal_tags
   - user_saved_searches

âœ… NEW MongoDB Collections (2 total):
   - conversations (session management & state tracking)
   - chat_messages (AI chat message storage)

âœ… Core Features:
   - Complete user management & authentication
   - Project collaboration with roles & permissions
   - Git-like branching for LaTeX projects (NEW!)
   - Real-time collaborative editing (NEW!)
   - Asana-like task management system
   - Journal/notebook system (NEW!)
   - Paper management with semantic search
   - LaTeX version control & conflict resolution
   - AI-powered chat with session management (NEW!)
   - Advanced analytics & user behavior tracking (NEW!)
   - External project invitations

âœ… Task Management (11 tables):
   - task_lists, tasks, task_assignees
   - task_dependencies, task_comments, task_attachments  
   - task_time_logs, task_tags, task_activity
   - task_watchers, task_recurrence

âœ… Paper Embeddings & Semantic Search:
   - paper_embeddings table with 384-dimensional vectors
   - Uses all-mini-lmv6 model for embedding generation
   - Concatenated diagnostic text as source material
   - IVFFlat index for fast cosine similarity search
   - Processing pipeline: GROBID â†’ Diagnostics â†’ Embeddings
   - Status tracking and error handling for reliable processing
   - Supports semantic paper search and similarity matching

âœ… Advanced Git Integration:
   - Full branching system with merge/conflict resolution
   - Branch-level permissions (read/write/admin)
   - LaTeX file management per branch
   - Real-time collaborative editing with CRDT
   - Automated autosave queue with priority handling

âœ… Analytics & Monitoring:
   - User feature usage tracking
   - Daily engagement metrics
   - Behavioral pattern analysis  
   - A/B testing framework
   - System performance metrics
   - Detailed session tracking

ðŸš€ Production-ready with advanced collaboration features!

Commands to verify setup:
- PostgreSQL: sudo -u postgres psql -d resxiv -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"
- MongoDB: python -c "from pymongo import MongoClient; client = MongoClient(); db = client.resxiv_chat; print('Collections:', db.list_collection_names())"

ðŸ“ NOTE: All analytics tables, indexes, functions, and examples 
     are included in the main schema above. This completes the 
     ResXiv database setup documentation.

END OF SCHEMA ==========================================
