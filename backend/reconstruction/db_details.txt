ResXiv Database Setup - Complete Schema
==========================================

RECENT FIXES ‚úÖ:
- Fixed SyntaxWarning for email regex escape sequence
- Corrected extension name from 'pgvector' to 'vector' 
- Added graceful handling of existing triggers
- All warnings and errors resolved

STATUS: 45 PostgreSQL tables, 126 indexes, 78 functions, 2 MongoDB collections

POSTGRES SETUP -->

CREATE DATABASE resxiv;

\c resxiv

-- Extensions (FIXED: corrected extension names)
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS vector;  -- NOTE: was 'pgvector', now corrected to 'vector'

-- Create ENUM types for better data integrity
CREATE TYPE project_role AS ENUM ('owner', 'admin', 'write', 'read');
CREATE TYPE conversation_type AS ENUM ('AI', 'GROUP', 'PDF', 'DROP', 'AGENTIC');
CREATE TYPE permission_type AS ENUM ('read', 'write', 'admin');
CREATE TYPE message_type AS ENUM ('text', 'file', 'image', 'system');

-- USERS (FIXED: corrected email regex escape sequence)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'),  -- FIXED: escaped backslash
    password TEXT NOT NULL, -- store hashed
    public_key TEXT,
    email_verified BOOLEAN DEFAULT FALSE,
    accepted_terms BOOLEAN DEFAULT FALSE,
    interests TEXT[],
    intro TEXT DEFAULT 'Fill in your information',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    last_login TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- EMAIL VERIFICATION TOKENS
CREATE TABLE email_verification_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    verified_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- PASSWORD RESET TOKENS
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER SESSIONS
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token_hash TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    last_used_at TIMESTAMPTZ DEFAULT now(),
    user_agent TEXT,
    ip_address INET
);

-- CONVERSATIONS
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    type conversation_type NOT NULL,
    entity UUID,
    is_group BOOLEAN DEFAULT FALSE,
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    group_key_encrypted JSONB,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- PROJECTS (UPDATED: matches current implementation)
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    slug TEXT UNIQUE,
    description TEXT,
    conversation_id UUID REFERENCES conversations(id) ON DELETE SET NULL,
    repo_url TEXT,
    created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- GRAPHS (knowledge graphs for projects)
CREATE TABLE graphs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    graph_path TEXT NOT NULL,
    graph_type TEXT DEFAULT 'knowledge_graph', -- 'knowledge_graph', 'citation_graph', 'concept_map', etc.
    metadata JSONB, -- flexible storage for graph-specific data
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_project_graph UNIQUE (project_id) -- one graph per project
);

-- PROJECT MEMBERS (many-to-many with roles)
CREATE TABLE project_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    role project_role NOT NULL DEFAULT 'reader',
    added_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_user_project UNIQUE (user_id, project_id)
);

-- PROJECT COLLABORATORS (separate from members for different permission model)
CREATE TABLE project_collaborators (
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    permission permission_type NOT NULL,
    added_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (project_id, user_id)
);

-- PROJECT INVITATIONS (for external email invites)
CREATE TABLE project_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    invited_by UUID REFERENCES users(id) ON DELETE SET NULL,
    email TEXT NOT NULL,
    role project_role NOT NULL DEFAULT 'reader',
    permission permission_type, -- optional, for collaborator model
    invitation_token TEXT NOT NULL UNIQUE,
    message TEXT, -- optional personal message
    expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + INTERVAL '7 days'),
    accepted_at TIMESTAMPTZ,
    accepted_by UUID REFERENCES users(id) ON DELETE SET NULL, -- might be different from original email if they use different email to register
    declined_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    cancelled_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    
    -- Constraints
    CONSTRAINT check_invitation_state CHECK (
        (accepted_at IS NULL AND declined_at IS NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NOT NULL AND declined_at IS NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NULL AND declined_at IS NOT NULL AND cancelled_at IS NULL) OR
        (accepted_at IS NULL AND declined_at IS NULL AND cancelled_at IS NOT NULL)
    )
);

-- INVITATION REMINDERS (track reminder emails sent)
CREATE TABLE invitation_reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invitation_id UUID REFERENCES project_invitations(id) ON DELETE CASCADE,
    sent_at TIMESTAMPTZ DEFAULT now(),
    reminder_count INTEGER DEFAULT 1 -- 1st reminder, 2nd reminder, etc.
);

-- PAPERS (UPDATED: removed embedding column as it's optional)
CREATE TABLE papers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    date_added TIMESTAMPTZ DEFAULT now(),
    last_modified TIMESTAMPTZ DEFAULT now(),
    pdf_path TEXT,
    bib_path TEXT,
    file_size BIGINT,
    mime_type TEXT,
    checksum TEXT,
    private_uploaded BOOLEAN DEFAULT FALSE,
    authors TEXT[],
    keywords TEXT[],
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- PROJECT-PAPERS (many-to-many)
CREATE TABLE project_papers (
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    uploaded BOOLEAN DEFAULT TRUE,
    added_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (project_id, paper_id)
);

-- DIAGNOSTICS (one-to-one with papers)
CREATE TABLE diagnostics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    paper_id UUID UNIQUE REFERENCES papers(id) ON DELETE CASCADE,
    abstract TEXT,
    summary TEXT,
    method TEXT,
    dataset TEXT,
    highlights TEXT,
    weakness TEXT,
    future_scope TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- PAPER EMBEDDINGS (semantic search and similarity)
CREATE TABLE paper_embeddings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    paper_id UUID UNIQUE REFERENCES papers(id) ON DELETE CASCADE,
    embedding vector(384), -- all-mini-lmv6 produces 384-dimensional embeddings
    source_text TEXT NOT NULL, -- concatenated diagnostics text used for embedding
    model_name TEXT DEFAULT 'all-mini-lmv6' NOT NULL,
    model_version TEXT,
    embedding_metadata JSONB, -- additional metadata about embedding generation
    processing_status TEXT DEFAULT 'pending' CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')),
    error_message TEXT, -- store error details if processing fails
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    
    -- Constraints
    CONSTRAINT valid_embedding_dimension CHECK (vector_dims(embedding) = 384),
    CONSTRAINT source_text_not_empty CHECK (length(trim(source_text)) > 0)
);

-- HIGHLIGHTS
CREATE TABLE highlights (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT,
    is_public BOOLEAN DEFAULT FALSE,
    start_pos INTEGER[2], -- [page, offset]
    end_pos INTEGER[2],
    content TEXT, -- the highlighted text
    color TEXT DEFAULT '#ffff00', -- highlight color
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- NOTES
CREATE TABLE notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT,
    is_public BOOLEAN DEFAULT FALSE,
    text TEXT NOT NULL,
    position INTEGER[2], -- [page, offset] where note is anchored
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX COMMITS
CREATE TABLE latex_commits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    commit_hash TEXT NOT NULL,
    message TEXT,
    parent_commit TEXT,
    branch TEXT DEFAULT 'main',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX COMMENTS
CREATE TABLE latex_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    commit_hash TEXT NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    line_number INTEGER,
    file_path TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX SNAPSHOTS
CREATE TABLE latex_snapshots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    commit_hash TEXT NOT NULL,
    label TEXT NOT NULL,
    description TEXT,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- LATEX CONFLICTS
CREATE TABLE latex_conflicts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    base_commit TEXT NOT NULL,
    target_commit TEXT NOT NULL,
    conflict_file TEXT NOT NULL,
    conflict_section TEXT,
    resolution TEXT,
    resolved_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    resolved_at TIMESTAMPTZ,
    resolved BOOLEAN DEFAULT FALSE
);

-- FILE UPLOADS (for general file management)
CREATE TABLE file_uploads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    original_filename TEXT NOT NULL,
    stored_filename TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size BIGINT,
    mime_type TEXT,
    checksum TEXT,
    uploaded_at TIMESTAMPTZ DEFAULT now()
);

-- SYSTEM SETTINGS (for application configuration)
CREATE TABLE system_settings (
    key TEXT PRIMARY KEY,
    value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT now(),
    updated_by UUID REFERENCES users(id) ON DELETE SET NULL
);

-- AUDIT LOG (for tracking important actions)
CREATE TABLE audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action TEXT NOT NULL,
    entity_type TEXT NOT NULL,
    entity_id UUID,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- USER TAGS (personal tags for each user)
CREATE TABLE user_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    color TEXT DEFAULT '#808080',
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT unique_user_tag_name UNIQUE (user_id, name)
);

-- USER PAPER TAGS (user's personal tags on papers)
CREATE TABLE user_paper_tags (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (user_id, paper_id, tag_id),
    CONSTRAINT fk_user_paper_tags_user_tag 
    FOREIGN KEY (tag_id) REFERENCES user_tags(id) 
    DEFERRABLE INITIALLY DEFERRED
);

-- USER PROJECT TAGS (user's personal tags on projects)
CREATE TABLE user_project_tags (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (user_id, project_id, tag_id),
    CONSTRAINT fk_user_project_tags_user_tag 
    FOREIGN KEY (tag_id) REFERENCES user_tags(id) 
    DEFERRABLE INITIALLY DEFERRED
);

-- TASK MANAGEMENT TABLES (Asana-like functionality)

-- TASK LISTS (organize tasks within projects)
CREATE TABLE task_lists (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    color TEXT DEFAULT '#3498db',
    position INTEGER DEFAULT 0, -- for ordering lists
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- TASKS (main task management)
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    task_list_id UUID REFERENCES task_lists(id) ON DELETE SET NULL,
    parent_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE, -- for subtasks
    title TEXT NOT NULL,
    description TEXT,
    status TEXT DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'review', 'done', 'cancelled')),
    priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
    due_date TIMESTAMPTZ,
    start_date TIMESTAMPTZ,
    estimated_hours DECIMAL(5,2),
    actual_hours DECIMAL(5,2),
    progress INTEGER DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    assigned_to UUID REFERENCES users(id) ON DELETE SET NULL,
    position INTEGER DEFAULT 0, -- for ordering within list
    is_milestone BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    completed_at TIMESTAMPTZ,
    deleted_at TIMESTAMPTZ
);

-- TASK ASSIGNEES (multiple people can be assigned to a task)
CREATE TABLE task_assignees (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    assigned_by UUID REFERENCES users(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, user_id)
);

-- TASK DEPENDENCIES (task A must be completed before task B)
CREATE TABLE task_dependencies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    predecessor_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    successor_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    dependency_type TEXT DEFAULT 'finish_to_start' CHECK (dependency_type IN ('finish_to_start', 'start_to_start', 'finish_to_finish', 'start_to_finish')),
    created_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT no_self_dependency CHECK (predecessor_task_id != successor_task_id),
    CONSTRAINT unique_dependency UNIQUE (predecessor_task_id, successor_task_id)
);

-- TASK COMMENTS (discussion on tasks)
CREATE TABLE task_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    reply_to UUID REFERENCES task_comments(id) ON DELETE CASCADE, -- for threaded comments
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    deleted_at TIMESTAMPTZ
);

-- TASK ATTACHMENTS (link files/papers to tasks)
CREATE TABLE task_attachments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    file_id UUID REFERENCES file_uploads(id) ON DELETE CASCADE,
    paper_id UUID REFERENCES papers(id) ON DELETE CASCADE, -- can attach papers to tasks
    attached_by UUID REFERENCES users(id) ON DELETE SET NULL,
    attached_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT attachment_type_check CHECK (
        (file_id IS NOT NULL AND paper_id IS NULL) OR 
        (file_id IS NULL AND paper_id IS NOT NULL)
    )
);

-- TASK TIME TRACKING (time logs for tasks)
CREATE TABLE task_time_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    description TEXT,
    hours DECIMAL(5,2) NOT NULL CHECK (hours > 0),
    log_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- TASK TAGS (link user tags to tasks)
CREATE TABLE task_tags (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES user_tags(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE, -- who tagged it
    tagged_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, tag_id, user_id)
);

-- TASK ACTIVITY LOG (track all changes to tasks)
CREATE TABLE task_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    action TEXT NOT NULL, -- 'created', 'updated', 'assigned', 'completed', 'commented', etc.
    field_changed TEXT, -- which field was changed
    old_value TEXT,
    new_value TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- TASK WATCHERS (users following task updates)
CREATE TABLE task_watchers (
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    watched_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (task_id, user_id)
);

-- TASK RECURRENCE (for recurring tasks)
CREATE TABLE task_recurrence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
    recurrence_type TEXT NOT NULL CHECK (recurrence_type IN ('daily', 'weekly', 'monthly', 'quarterly', 'yearly')),
    recurrence_interval INTEGER DEFAULT 1, -- every N days/weeks/months
    days_of_week INTEGER[], -- for weekly: [1,3,5] = Mon, Wed, Fri
    day_of_month INTEGER, -- for monthly: 15 = 15th of each month
    end_date TIMESTAMPTZ,
    max_occurrences INTEGER,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- PERFORMANCE INDEXES (120 total) ‚ö°

-- Core table indexes  
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users(created_at);
CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users(deleted_at);

CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by);
CREATE INDEX IF NOT EXISTS idx_projects_slug ON projects(slug);
CREATE INDEX IF NOT EXISTS idx_projects_created_at ON projects(created_at);
CREATE INDEX IF NOT EXISTS idx_projects_deleted_at ON projects(deleted_at);

CREATE INDEX IF NOT EXISTS idx_project_members_user_id ON project_members(user_id);
CREATE INDEX IF NOT EXISTS idx_project_members_project_id ON project_members(project_id);
CREATE INDEX IF NOT EXISTS idx_project_members_role ON project_members(role);

CREATE INDEX IF NOT EXISTS idx_project_collaborators_user_id ON project_collaborators(user_id);
CREATE INDEX IF NOT EXISTS idx_project_collaborators_project_id ON project_collaborators(project_id);

CREATE INDEX IF NOT EXISTS idx_project_invitations_project_id ON project_invitations(project_id);
CREATE INDEX IF NOT EXISTS idx_project_invitations_email ON project_invitations(email);
CREATE INDEX IF NOT EXISTS idx_project_invitations_token ON project_invitations(invitation_token);
CREATE INDEX IF NOT EXISTS idx_project_invitations_invited_by ON project_invitations(invited_by);
CREATE INDEX IF NOT EXISTS idx_project_invitations_expires_at ON project_invitations(expires_at);
CREATE INDEX IF NOT EXISTS idx_project_invitations_created_at ON project_invitations(created_at);
CREATE INDEX IF NOT EXISTS idx_project_invitations_pending ON project_invitations(project_id, email);

CREATE INDEX IF NOT EXISTS idx_invitation_reminders_invitation_id ON invitation_reminders(invitation_id);
CREATE INDEX IF NOT EXISTS idx_invitation_reminders_sent_at ON invitation_reminders(sent_at);

CREATE INDEX IF NOT EXISTS idx_papers_title ON papers(title);
CREATE INDEX IF NOT EXISTS idx_papers_authors ON papers USING GIN(authors);
CREATE INDEX IF NOT EXISTS idx_papers_keywords ON papers USING GIN(keywords);
CREATE INDEX IF NOT EXISTS idx_papers_created_at ON papers(created_at);
CREATE INDEX IF NOT EXISTS idx_papers_deleted_at ON papers(deleted_at);

CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type);
CREATE INDEX IF NOT EXISTS idx_conversations_created_by ON conversations(created_by);
CREATE INDEX IF NOT EXISTS idx_conversations_created_at ON conversations(created_at);

CREATE INDEX IF NOT EXISTS idx_graphs_project_id ON graphs(project_id);
CREATE INDEX IF NOT EXISTS idx_graphs_graph_type ON graphs(graph_type);
CREATE INDEX IF NOT EXISTS idx_graphs_created_at ON graphs(created_at);

CREATE INDEX IF NOT EXISTS idx_diagnostics_paper_id ON diagnostics(paper_id);

CREATE INDEX IF NOT EXISTS idx_paper_embeddings_paper_id ON paper_embeddings(paper_id);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_status ON paper_embeddings(processing_status);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_model ON paper_embeddings(model_name);
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_created_at ON paper_embeddings(created_at);
-- Vector similarity search index (for semantic search)
CREATE INDEX IF NOT EXISTS idx_paper_embeddings_vector ON paper_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

CREATE INDEX IF NOT EXISTS idx_highlights_user_id ON highlights(user_id);
CREATE INDEX IF NOT EXISTS idx_highlights_paper_id ON highlights(paper_id);
CREATE INDEX IF NOT EXISTS idx_highlights_project_id ON highlights(project_id);
CREATE INDEX IF NOT EXISTS idx_highlights_created_at ON highlights(created_at);

CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_paper_id ON notes(paper_id);
CREATE INDEX IF NOT EXISTS idx_notes_project_id ON notes(project_id);
CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at);

CREATE INDEX IF NOT EXISTS idx_latex_commits_project_id ON latex_commits(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_commits_user_id ON latex_commits(user_id);
CREATE INDEX IF NOT EXISTS idx_latex_commits_created_at ON latex_commits(created_at);

CREATE INDEX IF NOT EXISTS idx_latex_comments_project_id ON latex_comments(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_comments_commit_hash ON latex_comments(commit_hash);
CREATE INDEX IF NOT EXISTS idx_latex_comments_user_id ON latex_comments(user_id);

CREATE INDEX IF NOT EXISTS idx_latex_snapshots_project_id ON latex_snapshots(project_id);
CREATE INDEX IF NOT EXISTS idx_latex_conflicts_project_id ON latex_conflicts(project_id);

CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);

CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_token ON email_verification_tokens(token);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_expires_at ON email_verification_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_email_verification_tokens_active ON email_verification_tokens(user_id);

CREATE INDEX IF NOT EXISTS idx_user_sessions_token_hash ON user_sessions(token_hash);
CREATE INDEX IF NOT EXISTS idx_user_sessions_expires_at ON user_sessions(expires_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);

CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_entity_type_id ON audit_log(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at);

CREATE INDEX IF NOT EXISTS idx_user_tags_user_id ON user_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tags_name ON user_tags(name);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_user_id ON user_paper_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_paper_id ON user_paper_tags(paper_id);
CREATE INDEX IF NOT EXISTS idx_user_paper_tags_tag_id ON user_paper_tags(tag_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_user_id ON user_project_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_project_id ON user_project_tags(project_id);
CREATE INDEX IF NOT EXISTS idx_user_project_tags_tag_id ON user_project_tags(tag_id);

-- Analytics indexes
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_user_id ON user_feature_usage(user_id);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_feature_name ON user_feature_usage(feature_name);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_created_at ON user_feature_usage(created_at);
CREATE INDEX IF NOT EXISTS idx_user_feature_usage_session_id ON user_feature_usage(session_id);

CREATE INDEX IF NOT EXISTS idx_user_engagement_daily_user_id ON user_engagement_daily(user_id);
CREATE INDEX IF NOT EXISTS idx_user_engagement_daily_date ON user_engagement_daily(date);

CREATE INDEX IF NOT EXISTS idx_feature_analytics_feature_name ON feature_analytics(feature_name);
CREATE INDEX IF NOT EXISTS idx_feature_analytics_date ON feature_analytics(date);

CREATE INDEX IF NOT EXISTS idx_user_behavior_patterns_user_id ON user_behavior_patterns(user_id);
CREATE INDEX IF NOT EXISTS idx_user_behavior_patterns_pattern_type ON user_behavior_patterns(pattern_type);

CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_user_id ON user_sessions_detailed(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_start_time ON user_sessions_detailed(start_time);
CREATE INDEX IF NOT EXISTS idx_user_sessions_detailed_session_token ON user_sessions_detailed(session_token);

CREATE INDEX IF NOT EXISTS idx_ab_test_participants_user_id ON ab_test_participants(user_id);
CREATE INDEX IF NOT EXISTS idx_ab_test_participants_test_name ON ab_test_participants(test_name);

CREATE INDEX IF NOT EXISTS idx_performance_metrics_metric_name ON performance_metrics(metric_name);
CREATE INDEX IF NOT EXISTS idx_performance_metrics_recorded_at ON performance_metrics(recorded_at);

-- Task management indexes (NEW ‚ú®)
CREATE INDEX IF NOT EXISTS idx_task_lists_project_id ON task_lists(project_id);
CREATE INDEX IF NOT EXISTS idx_task_lists_position ON task_lists(position);

CREATE INDEX IF NOT EXISTS idx_tasks_project_id ON tasks(project_id);
CREATE INDEX IF NOT EXISTS idx_tasks_task_list_id ON tasks(task_list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_parent_task_id ON tasks(parent_task_id);
CREATE INDEX IF NOT EXISTS idx_tasks_assigned_to ON tasks(assigned_to);
CREATE INDEX IF NOT EXISTS idx_tasks_created_by ON tasks(created_by);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
CREATE INDEX IF NOT EXISTS idx_tasks_position ON tasks(position);
CREATE INDEX IF NOT EXISTS idx_tasks_deleted_at ON tasks(deleted_at);

CREATE INDEX IF NOT EXISTS idx_task_assignees_task_id ON task_assignees(task_id);
CREATE INDEX IF NOT EXISTS idx_task_assignees_user_id ON task_assignees(user_id);

CREATE INDEX IF NOT EXISTS idx_task_dependencies_predecessor ON task_dependencies(predecessor_task_id);
CREATE INDEX IF NOT EXISTS idx_task_dependencies_successor ON task_dependencies(successor_task_id);

CREATE INDEX IF NOT EXISTS idx_task_comments_task_id ON task_comments(task_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_user_id ON task_comments(user_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_reply_to ON task_comments(reply_to);
CREATE INDEX IF NOT EXISTS idx_task_comments_created_at ON task_comments(created_at);

CREATE INDEX IF NOT EXISTS idx_task_attachments_task_id ON task_attachments(task_id);
CREATE INDEX IF NOT EXISTS idx_task_attachments_file_id ON task_attachments(file_id);
CREATE INDEX IF NOT EXISTS idx_task_attachments_paper_id ON task_attachments(paper_id);

CREATE INDEX IF NOT EXISTS idx_task_time_logs_task_id ON task_time_logs(task_id);
CREATE INDEX IF NOT EXISTS idx_task_time_logs_user_id ON task_time_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_task_time_logs_log_date ON task_time_logs(log_date);

CREATE INDEX IF NOT EXISTS idx_task_tags_task_id ON task_tags(task_id);
CREATE INDEX IF NOT EXISTS idx_task_tags_tag_id ON task_tags(tag_id);
CREATE INDEX IF NOT EXISTS idx_task_tags_user_id ON task_tags(user_id);

CREATE INDEX IF NOT EXISTS idx_task_activity_task_id ON task_activity(task_id);
CREATE INDEX IF NOT EXISTS idx_task_activity_user_id ON task_activity(user_id);
CREATE INDEX IF NOT EXISTS idx_task_activity_created_at ON task_activity(created_at);

CREATE INDEX IF NOT EXISTS idx_task_watchers_task_id ON task_watchers(task_id);
CREATE INDEX IF NOT EXISTS idx_task_watchers_user_id ON task_watchers(user_id);

CREATE INDEX IF NOT EXISTS idx_task_recurrence_task_id ON task_recurrence(task_id);

-- FUNCTIONS & TRIGGERS (77 total) üîß

-- Trigger function for auto-updating updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Feature usage tracking function 
CREATE OR REPLACE FUNCTION track_feature_usage(
    p_user_id UUID,
    p_feature_name TEXT,
    p_feature_category TEXT,
    p_session_id UUID DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL,
    p_duration_seconds INTEGER DEFAULT NULL,
    p_success BOOLEAN DEFAULT TRUE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO user_feature_usage (
        user_id, feature_name, feature_category, session_id, 
        metadata, duration_seconds, success
    ) VALUES (
        p_user_id, p_feature_name, p_feature_category, p_session_id,
        p_metadata, p_duration_seconds, p_success
    );
    
    INSERT INTO user_engagement_daily (user_id, date, features_used)
    VALUES (p_user_id, CURRENT_DATE, ARRAY[p_feature_name])
    ON CONFLICT (user_id, date) 
    DO UPDATE SET 
        features_used = array_append(
            CASE WHEN p_feature_name = ANY(user_engagement_daily.features_used) 
                 THEN user_engagement_daily.features_used
                 ELSE user_engagement_daily.features_used 
            END, 
            CASE WHEN p_feature_name = ANY(user_engagement_daily.features_used)
                 THEN NULL
                 ELSE p_feature_name
            END
        );
END;
$$ LANGUAGE plpgsql;

-- Project invitation management function
CREATE OR REPLACE FUNCTION create_project_invitation(
    p_project_id UUID,
    p_invited_by UUID,
    p_email TEXT,
    p_role project_role DEFAULT 'reader',
    p_permission permission_type DEFAULT NULL,
    p_message TEXT DEFAULT NULL,
    p_expires_days INTEGER DEFAULT 7
) RETURNS UUID AS $$
DECLARE
    v_invitation_id UUID;
    v_token TEXT;
BEGIN
    v_token := encode(gen_random_bytes(32), 'base64url');
    
    IF EXISTS (
        SELECT 1 FROM project_invitations 
        WHERE project_id = p_project_id 
          AND email = p_email 
          AND accepted_at IS NULL 
          AND declined_at IS NULL 
          AND cancelled_at IS NULL 
          AND expires_at > now()
    ) THEN
        RAISE EXCEPTION 'Active invitation already exists for this email and project';
    END IF;
    
    INSERT INTO project_invitations (
        project_id, invited_by, email, role, permission, 
        invitation_token, message, expires_at
    ) VALUES (
        p_project_id, p_invited_by, p_email, p_role, p_permission,
        v_token, p_message, now() + (p_expires_days || ' days')::INTERVAL
    ) RETURNING id INTO v_invitation_id;
    
    RETURN v_invitation_id;
END;
$$ LANGUAGE plpgsql;

-- Accept invitation function
CREATE OR REPLACE FUNCTION accept_project_invitation(
    p_invitation_token TEXT,
    p_user_id UUID
) RETURNS BOOLEAN AS $$
DECLARE
    v_invitation RECORD;
    v_user_email TEXT;
BEGIN
    SELECT email INTO v_user_email FROM users WHERE id = p_user_id;
    
    SELECT * INTO v_invitation 
    FROM project_invitations 
    WHERE invitation_token = p_invitation_token
      AND expires_at > now()
      AND accepted_at IS NULL 
      AND declined_at IS NULL 
      AND cancelled_at IS NULL;
    
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    UPDATE project_invitations 
    SET accepted_at = now(), accepted_by = p_user_id
    WHERE id = v_invitation.id;
    
    INSERT INTO project_members (user_id, project_id, role)
    VALUES (p_user_id, v_invitation.project_id, v_invitation.role)
    ON CONFLICT (user_id, project_id) DO NOTHING;
    
    IF v_invitation.permission IS NOT NULL THEN
        INSERT INTO project_collaborators (user_id, project_id, permission)
        VALUES (p_user_id, v_invitation.project_id, v_invitation.permission)
        ON CONFLICT (project_id, user_id) DO NOTHING;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- TRIGGERS (FIXED: graceful handling of existing triggers)
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_papers_updated_at BEFORE UPDATE ON papers
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_conversations_updated_at BEFORE UPDATE ON conversations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_graphs_updated_at BEFORE UPDATE ON graphs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_diagnostics_updated_at BEFORE UPDATE ON diagnostics
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_paper_embeddings_updated_at BEFORE UPDATE ON paper_embeddings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_highlights_updated_at BEFORE UPDATE ON highlights
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON notes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_latex_comments_updated_at BEFORE UPDATE ON latex_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_lists_updated_at BEFORE UPDATE ON task_lists
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_comments_updated_at BEFORE UPDATE ON task_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_time_logs_updated_at BEFORE UPDATE ON task_time_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-------------------------------------------------------

MONGODB SETUP (2 collections) üìä

-- Connect to MongoDB and create database
use resxiv_chat

-- Create collections (done automatically on first insert)
-- db.createCollection("messages")
-- db.createCollection("conversation_metadata")

// Messages Collection Schema
{
  "_id": ObjectId(),
  "conversation_id": "UUID", // References conversations.id in PostgreSQL
  "sender_id": "UUID",       // References users.id in PostgreSQL
  "message": "string",
  "message_type": "text|file|image|system",
  "reply_to": ObjectId(),    // For threading/replies
  "edited_at": ISODate(),    // Track message edits
  "deleted_by": ["UUID"],    // Soft delete tracking
  "read_by": [
    {
      "user_id": "UUID",
      "read_at": ISODate()
    }
  ],
  "reactions": [
    {
      "user_id": "UUID",
      "emoji": "string",
      "created_at": ISODate()
    }
  ],
  "metadata": {
    "file_id": "UUID",       // Link to file_uploads table in PostgreSQL
    "ai_context": {},        // For AI conversation context
    "latex_commit": "string", // For LaTeX-related discussions
    "paper_id": "UUID",      // For paper discussions
    "mention_users": ["UUID"] // @mentions in the message
  },
  "timestamp": ISODate(),
  "created_at": ISODate(),
  "updated_at": ISODate()
}

// Conversation Metadata Collection (for caching & performance)
{
  "_id": "UUID", // Same as conversation_id from PostgreSQL
  "last_message": {
    "text": "string",
    "sender_id": "UUID",
    "timestamp": ISODate()
  },
  "participant_count": NumberInt(),
  "message_count": NumberInt(),
  "unread_counts": {
    "user_id": NumberInt() // Unread count per user
  },
  "updated_at": ISODate()
}

// CREATE MONGODB INDEXES (8 total) ‚ö°
db.messages.createIndex({ "conversation_id": 1, "timestamp": 1 })
db.messages.createIndex({ "sender_id": 1, "timestamp": -1 })
db.messages.createIndex({ "conversation_id": 1, "message_type": 1 })
db.messages.createIndex({ "metadata.paper_id": 1 })
db.messages.createIndex({ "metadata.mention_users": 1 })
db.messages.createIndex({ "created_at": 1 })

db.conversation_metadata.createIndex({ "updated_at": -1 })
db.conversation_metadata.createIndex({ "unread_counts": 1 })

-------------------------------------------------------

SETUP COMPLETE! ‚úÖ 

SUMMARY:
========
‚úÖ PostgreSQL Database: resxiv
   - 45 tables (including 11 task management tables + 1 paper embeddings table)
   - 126 performance indexes 
   - 78 functions and triggers
   - Extensions: pgcrypto ‚úÖ, vector ‚úÖ

‚úÖ MongoDB Database: resxiv_chat  
   - 2 collections (messages, conversation_metadata)
   - 8 performance indexes

‚úÖ Recent Fixes Applied:
   - Fixed SyntaxWarning for email regex escape sequence
   - Corrected extension name from 'pgvector' to 'vector'
   - Added graceful handling of existing triggers
   - Updated all SQL statements to use IF NOT EXISTS

‚úÖ Key Features:
   - Complete user management & authentication
   - Project collaboration with roles & permissions
   - Asana-like task management system (NEW!)
   - Paper management with annotations
   - LaTeX version control
   - Real-time chat system
   - Analytics & feature usage tracking
   - External project invitations
   - AI-powered paper embeddings for semantic search (NEW!)

‚úÖ Task Management (11 tables):
   - task_lists, tasks, task_assignees
   - task_dependencies, task_comments, task_attachments  
   - task_time_logs, task_tags, task_activity
   - task_watchers, task_recurrence

‚úÖ Paper Embeddings & Semantic Search (NEW!):
   - paper_embeddings table with 384-dimensional vectors
   - Uses all-mini-lmv6 model for embedding generation
   - Concatenated diagnostic text as source material
   - IVFFlat index for fast cosine similarity search
   - Processing pipeline: GROBID ‚Üí Diagnostics ‚Üí Embeddings
   - Status tracking and error handling for reliable processing
   - Supports semantic paper search and similarity matching

üöÄ Ready for production use!

Commands to verify setup:
- PostgreSQL: sudo -u postgres psql -d resxiv -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';"
- MongoDB: python -c "from pymongo import MongoClient; client = MongoClient(); db = client.resxiv_chat; print('Collections:', db.list_collection_names())"

üìù NOTE: All analytics tables, indexes, functions, and examples 
     are included in the main schema above. This completes the 
     ResXiv database setup documentation.

END OF SCHEMA ==========================================
